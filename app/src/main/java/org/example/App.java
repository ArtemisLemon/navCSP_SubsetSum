/*
 * This source file was generated by the Gradle 'init' task
 */
package org.example;

import java.util.Random;
import java.util.List;
import java.util.ArrayList;
import java.util.Hashtable;
import java.util.stream.IntStream;

import org.chocosolver.solver.*;
import org.chocosolver.solver.constraints.Constraint;
import org.chocosolver.solver.search.strategy.Search;
import org.chocosolver.solver.variables.IntVar;
import org.chocosolver.util.tools.ArrayUtils;


public class App {
    static Model m = new Model();
    static int elem = 0;


    static IntVar[] navCSP(IntVar[] source, IntVar[][] sources, int lb, int ub, IntVar dummy){
        int s = source.length;
        int ss = sources[0].length;
        int sss = s*ss;
        IntVar[] out = m.intVarArray(sss,lb,ub);
        IntVar[] dummies = new IntVar[ss]; for(int i=0;i<ss;i++) dummies[i] = dummy;//copy dummy ss times
        // IntVar[] table = ArrayUtils.concat(ArrayUtils.flatten(sources),dummies); //flatten sources, dummies at the end (ub--)
        IntVar[] table = ArrayUtils.concat(dummies, ArrayUtils.flatten(sources)); //flatten sources, dummies at the end (lb++)
        
        // for(int i=0;i<sss;i++) m.element(out[i], table, pointer,0);
        int k=0;
        for(int i=0; i<s;i++) for(int j=0;j<ss;j++){
            // System.out.println("element "+elem++);
            IntVar pointer = source[i].mul(ss).add(j).intVar(); // = pointer arithm
            m.element(out[k++], table, pointer,0).post();
        }
        return out;
    }

    private static void shuffleArray(int[] array){
        int index;
        Random random = new Random();
        for (int i = array.length - 1; i > 0; i--)
        {
            index = random.nextInt(i + 1);
            if (index != i)
            {
                array[index] ^= array[i];
                array[i] ^= array[index];
                array[index] ^= array[i];
            }
        }
    }

    public static void main(String[] args) {
        // Problem Size
        int objects=80;
        int n=5; //MaxCard
        int r=6; //navigations
        int multi=20; //number of different elements
        int first=10; //value of first elements
        int xtrm=1000; //domain extremes
        // int tgtsum = 10; //Min subset sum
        // int tgtsum = (objects/2)*(first + (first+objects-1)); //Max subset sum
        int tgtsum = 1;

        // Object we apply the subset sum to
        int startObj = 0;

        // Make Data
        int[] attribs = new int[objects];
        for(int i=0;i<objects;i++) attribs[i] = i%multi+first;
        // for(int i=0;i<objects;i++) attribs[i]= i;
        // attribs[objects/2]=objects;
        // for(int i=0;i<objects;i++) attribs[i]-=(objects/2);
        shuffleArray(attribs);
        // for(int i=0;i<objects;i++) if(i%2!=0) attribs[i]*=-1;

        IntVar[][] attribTable = new IntVar[objects][1]; //objects number of variables of domain of size 1
        for(int i=0;i<objects;i++){
            attribTable[i][0] = m.intVar("attrib",attribs[i]);
            System.out.println(attribTable[i][0].getValue());
        }


        IntVar[][] table = m.intVarMatrix("table",objects, n, 0, objects); //objectsXn variables of domain of size objects
        IntVar dummy = m.intVar(0);

        IntVar[] vars = table[startObj];
        for(int i=0;i<r;i++){
            vars = navCSP(vars, table, 0, xtrm, dummy);
        }
        vars = navCSP(vars, attribTable, -xtrm, xtrm, dummy);

        m.allDifferentExcept0(vars).post();
        // m.allDifferent(vars).post();

        IntVar sum = m.intVar(tgtsum);
        m.sum(vars, "=", sum).post();

        // m.setObjective(true, sum);

        // m.getSolver().setSearch(Search.intVarSearch(ArrayUtils.flatten(table)), Search.inputOrderLBSearch(m.retrieveIntVars(true)));
        m.getSolver().setSearch(Search.intVarSearch(ArrayUtils.concat(vars,ArrayUtils.flatten(table))), Search.inputOrderLBSearch(m.retrieveIntVars(true)));

        // List<Solution> front = m.getSolver().findParetoFront(ArrayUtils.flatten(table),Model.MAXIMIZE); 
        // System.out.println("The pareto front has "+front.size()+" solutions : ");
        // for(Solution s: front){
        //         System.out.println(s);
        // }



        Solution solution = m.getSolver().findSolution();
        if(solution != null){
            // System.out.println(solution.toString());
            for (int o=0;o<objects;o++){
                String line = "object "+(o+1)+":"+attribs[o]+" -> ";
                for (int i=0;i<n;i++) line += table[o][i].getValue()+" ";
                System.out.println(line);
            }
            String line = "attributes connected to object 1 via navigation (|O|="+objects+", n="+n+", r="+r+")\n";
            for(var v : vars){
                line += v.getValue()+" ";
            }
            System.out.println(line);
        } else {
            for (int o=0;o<objects;o++){
                String line = "object "+(o+1)+":"+attribs[o]+" -> ";
                // for (int i=0;i<n;i++) line += table[o][i].getValue()+" ";
                System.out.println(line);
            }

            System.out.println("mmmhh");
        }
        m.getSolver().printStatistics();
    }
}
