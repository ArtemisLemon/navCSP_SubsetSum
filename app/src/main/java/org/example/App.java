/*
 * This source file was generated by the Gradle 'init' task
 */
package org.example;

import java.util.Random;
import java.util.List;
import java.util.ArrayList;
import java.util.Hashtable;
import java.util.stream.IntStream;

import org.chocosolver.solver.*;
import org.chocosolver.solver.constraints.Constraint;
import org.chocosolver.solver.search.strategy.Search;
import org.chocosolver.solver.variables.IntVar;
import org.chocosolver.util.tools.ArrayUtils;


public class App {
    static Model m = new Model();

    static IntVar[] navCSP(IntVar[] source, IntVar[][] sources, int lb, int ub, IntVar dummy){
        int n = source.length; // N
        int nn = sources[0].length; //N'
        int nnn = n*nn;
        IntVar[] out = m.intVarArray(nnn,lb,ub);
        IntVar[] dummies = new IntVar[nn]; for(int i=0;i<nn;i++) dummies[i] = dummy;//copy dummy ss times
        // IntVar[] table = ArrayUtils.concat(ArrayUtils.flatten(sources),dummies); //flatten sources, dummies at the end (ub--)
        IntVar[] table = ArrayUtils.concat(dummies, ArrayUtils.flatten(sources)); //flatten sources, dummies at the beginning (lb++)
        
        // for(int i=0;i<sss;i++) m.element(out[i], table, pointer,0);
        int k=0;
        for(int i=0; i<n;i++) for(int j=0;j<nn;j++){
            IntVar pointer = source[i].mul(nn).add(j).intVar(); // = pointer arithm
            m.element(out[k++], table, pointer,0).post();
        }
        return out;
    }

    private static void shuffleArray(int[] array){
        int index;
        Random random = new Random();
        for (int i = array.length - 1; i > 0; i--)
        {
            index = random.nextInt(i + 1);
            if (index != i)
            {
                array[index] ^= array[i];
                array[i] ^= array[index];
                array[index] ^= array[i];
            }
        }
    }

    public static void main(String[] args) {
        // Problem Size
        int objects=120; //number of objects, and size of domains
        int n=10; //MaxCard
        int r=2; //navigations
        int multi=20; //number of different elements
        int first=10; //first value of multiset
        int tgtsum = 33; //target sum
        int xtrm=1000; //domain extremes to init intermediate variables

        // Object we start the search for the subset from
        int startObj = 0; //0 in the object.table, will have 1 as pointer value (in nav tables)

        // Make Data
        int[] attribs = new int[objects];
        for(int i=0;i<objects;i++) attribs[i] = i%multi+first;
        shuffleArray(attribs);
        IntVar[][] attribTable = new IntVar[objects][1]; //variables holding instance model constants
        for(int i=0;i<objects;i++){
            attribTable[i][0] = m.intVar("attrib",attribs[i]);
            System.out.println(attribTable[i][0].getValue());
        }


        IntVar[][] table = m.intVarMatrix("table",objects, n, 0, objects); //objects*n variables of domain of size objects
        IntVar dummy = m.intVar(0); //nullptr

        IntVar[] vars = table[startObj];
        for(int i=0;i<r;i++){
            vars = navCSP(vars, table, 0, xtrm, dummy);
        }
        vars = navCSP(vars, attribTable, -xtrm, xtrm, dummy);

        m.allDifferentExcept0(vars).post(); //AllDiff Except nullptr
        // m.allDifferent(vars).post(); //means all links must be used

        IntVar sum = m.intVar(tgtsum);
        m.sum(vars, "=", sum).post();

        // Two different search strategies tested, the third one being "none"
        // Here select which variables are "important", the first to choose when searching
        // The first of these two strategies searching in "problem variables" from the UML CSP
        // m.getSolver().setSearch(Search.intVarSearch(ArrayUtils.flatten(table)), Search.inputOrderLBSearch(m.retrieveIntVars(true)));
        m.getSolver().setSearch(Search.intVarSearch(ArrayUtils.concat(vars,ArrayUtils.flatten(table))), Search.inputOrderLBSearch(m.retrieveIntVars(true)));
        // The second also searches in the "top most" OCL CSP variables, upon which the constraints are applied. It seems to be what provides quick disproving despite large wholes in the data


        // Here we start the Solver
        System.out.println("Model Built with "+m.getNbIntVar(false)+" variables");
        Solution solution = m.getSolver().findSolution();
        if(solution != null){
            // System.out.println(solution.toString());
            for (int o=0;o<objects;o++){
                String line = "object "+(o+1)+":"+attribs[o]+" -> ";
                for (int i=0;i<n;i++) line += table[o][i].getValue()+" ";
                System.out.println(line);
            }
            String line = "attributes connected to object 1 via navigation (|O|="+objects+", n="+n+", r="+r+")\n";
            for(var v : vars){
                line += v.getValue()+" ";
            }
            System.out.println(line);
        } else {
            for (int o=0;o<objects;o++){
                String line = "object "+(o+1)+":"+attribs[o];
                System.out.println(line);
            }
            System.out.println("mmmhh");
        }
        m.getSolver().printStatistics();
    }
}
